{"name":"Weft","tagline":"Weft CDI-Thread/Executor Provider","body":"### Yeah, We Know...\r\n\r\nTechnically, you're not supposed to execute logic in threads within a JEE application. There are (will be?) JEE mechanisms available for threaded processing.\r\n\r\nBut sometimes, in some CDI applications, it makes sense to manage your own threads. Weft is an API that organizes and injects Executor instances for your CDI application.\r\n\r\n### One Annotation To Create Them All\r\n\r\nControlling which executor gets injected is simple, using `org.commonjava.cdi.util.weft.ExecutorConfig`:\r\n\r\n```\r\n@ExecutorConfig( named=\"my-threads\" )\r\n@Inject\r\nprivate Executor executor;\r\n```\r\n\r\nIn case your executor isn't configured (see Configuring, below), you can also set some default parameters in the annotation:\r\n\r\n```\r\n@ExecutorConfig( named=\"my-threads\", daemon=true, priority=8, threads=10 )\r\n[...]\r\n```\r\n\r\n### Configuring\r\n\r\nThe `ExecutorProvider` component (which manages the Executor instances injected by Weft) `@Inject`'s an instance of `WeftConfig`, which can specify priorities, thread counts, and the daemon flag for each named Executor your application uses. It also accepts a default priority and thread count setting to be applied to any Executor not otherwise configured. Settings in the injected `WeftConfig` instance always override those given in the `@ExecutorConfig` annotation, allowing the user to fine tune threading in the installed application.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}